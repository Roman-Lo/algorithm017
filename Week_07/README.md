# 学习笔记

## 内容要点

### 前缀树（Trie）

特性：

* 节点本身不存具体的单词（节省空间）
* 从根节点开始，到某一个节点所走的路径顺序集合，为该节点对应的字符串
* 每一个节点的子节点路径都分别代表不一样的字符

具体实现：[trie.js](./impls/trie.js)

### 并查集（Disjoint Set）

主要解决组团和配对问题

具体实现: [disjoint-set.js](./impls/disjoint-set.js)

### 高级搜索

#### 剪枝

通过缓存等方式，在遍历过程中把已经检测过或者明确无效的路径进行记录，有效防止重复计算的做法。

比如：在计算`F(n) = F(n-1) + F(n-2)`的时候，我们可以缓存`F(n-1)`和`F(n-2`的结果，来降低复杂度。

#### 双向BFS

基于BFS特性，分别从头尾两端分别进行BFS，并选择其当前层相对小的一侧进行下一次遍历，直到元素在两个层集合中相遇。

#### 启发式搜索（A* Search）

基于优先队列中的最高权节点进行搜索。权重通过`启发式函数h(n)`计算得来，该函数通常考量指标有：

1. 欧拉距离（Euclidean Distance），即两坐标的空间直线距离；

2. 曼哈顿距离（Manhattan Distance)，即`M = |x1 - x2| + |y1 - y2|`；

### 平衡二叉搜索树

#### AVL树

* 每个节点需要额外存储空间`(-1,0,1)`分别代表当前节点的子树平衡状态（左右子树的高度差），称为 __平衡因子(Balance Factor)__
* 基本旋转步骤：
    1. 左旋：右右子树（2，1，0）
    1. 右旋：左左子树（-1，-1，0）
    1. 左右旋：左右子树（-2，1，0）
    1. 右左旋：右左子树（2，-1，0）

    其中`左右旋`和`右左旋`的第一步旋转主要是将当前树状态分别转换为`-1,-1,0`和`2,1,0`

#### 红黑树

红黑树是一棵近似平衡的二叉搜索树，它能确保任意一个节点均能满足其 __左右子树的高度差小于两倍__。

特性：

1. 定义节点颜色为`红`或`黑`

1. 根节点是`黑`

1. 每个叶子节点（包括空节点），都是`黑`

1. 相连接的两个节点不能同时为`红`

1. 从任意一个节点到其 __每一个叶子节点的所有路径都包含相同数量的`黑`节点__

#### AVL树与红黑树的对比

1. 由于AVL树比红黑树有 __更严格的平衡性__ ，因此AVL树会有更好（快）的 __搜索性能__

1. 红黑树由于严格性相对较低，因此其 __插入删除__ 时的操作成本会相对AVL更低

1. AVL树的平衡因子是一个整数类型，而红黑树的红黑状态用一个bit位即可标记，因此红黑树比AVL有 __更低(好)的空间开销__

1. 两者的特性差异构成了其应用场景的差异，其中：
    1. 如果读操作远比写入频繁的时候，通常使用AVL树来获得更好的查询性能（如 __数据库__ ）；
    1. 如果写操作比较频繁时，那么使用红黑树来作为数据结构会比较好，因为其写入成本低，且读取成本相对不会太高（一般高级语言类库中的 __Map__，__MultiMap__，__MultiSet__ 等）

## 习题部分

1. [实现 Trie (前缀树)](./impls/trie.js)

1. [[547] 朋友圈](./friend-circles.js)

1. [[212] 单词搜索 II](./word-search-ii.js)
