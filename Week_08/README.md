# 学习笔记

## 内容要点

### 计算机的二进制

* 二进制：基数为2的计数方法，计数符号由`0`或`1`组成，逢二进一；

* 二进制的三种编码：

  + 原码：符号位`0`为正，`1`为负，二进制在原始数学形式上的表示方式。

  + 反码：若符号位为`0`，则无需取反，即正数的反码与原码一致。反之，符号位外的所有位的数值取反。

  + 补码：若符号位为`0`，无需变化。反之，反码执行加一操作。

  综上所述：

  + 对于正数而言，其原码、反码、补码都一致。

  + 对于负数而言，反码为原码除符号位外取反，补码为其反码加一。

* 计算机中数字都是通过补码存储

* 加减法运算：基于二进制的特殊性以及逻辑电路设计简易性，实际CPU运算是不存在减法运算，即：`A-B` ==> `A+(-B)`；因此，实际上逻辑电路的数值加减运算都是补码相加。

### 位运算

根据二进制 `非零即一` 的特征，位运算的操作来源于逻辑运算的三种基本操作：

1. 与操作(`&`)

    1 & 1 = 1，1 & 0 = 0，0 & 0 = 0

2. 或操作(`|`)

    1 | 1 = 1，1 | 0 = 1，0 | 0 = 0

3. 异或操作(`^`)[逻辑学名：`exclusive OR`,  `xor`]

    1 ^ 1 = 0，1 ^ 0 = 1，0 ^ 0 = 0

上述三种操作在二进制数字里对应着按位进行操作，比如：

  0001 1000 ^ 0000 1011 = 0001 0000

此外，对应二进制数字还有 `位移` （ `>>` 右移, `<<` 左移）以及 `取反` （ `~` ）操作。

#### 快捷方式

1. 去除二进制最后一位`1`：

    

``` js
    n & (n - 1) // 1011 0000 ==> 1010 0000
```

1. 取最低位数值：

    

``` js
    n & 1 // 1011 1001 ==> 1
```

1. 除二向低位取整

    

``` js
    n >> 1 // Math.floor(n / 2);
```

### 布隆过滤器（Bloom Filter）

给出一个长度为 `m` 的二进制向量（位数组），并定义 `k` 个哈希函数，对于集合元素 `x` ，对其进行 `k` 次哈希函数计算，其结果散落在位数组中，并将其置 `1` 。

若给出元素 `y` ，经过定义的 `k` 次哈希得出的结果

1. 在数组上有一个为`0`，则该元素肯定不在集合中。

1. 在数组上全部为`1`，则该元素可能存在集合中。

### LRU(Least Recently Used)缓存

望文生义，缓存中元素使用访问时间作为权重，并逐步排除时间小的元素。

链接：https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)

### 排序

根据时间复杂度大致分为两种：

#### O(n^2)

1. 冒泡排序

1. 插入排序

1. 选择排序

#### O(nlogn)

1. 快速排序

    1. 从数列中挑出一个元素，称为`基准（pivot）`

    1. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为`分区（partition）`操作

    1. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序

2. 归并排序

    采用分治法，将数组一分为二直到仅有一个元素后，再两两合并子数组。

3. 堆排序

    构造一个大/小顶堆，并在堆顶元素与堆尾元素置换，此时堆长度减一，此时对堆顶元素进行 `heapifyDown` 操作。如此类推直到堆大小为1，排序结束。

## 习题部分

[146. LRU 缓存机制](./lru-cache.js)

[56. 合并区间](./merge-intervals.js)

[191. 位1的个数](./number-of-1-bits.js)

[231. 2的幂](./power-of-two.js)

[190. 颠倒二进制位](./reverse-bits.js)
