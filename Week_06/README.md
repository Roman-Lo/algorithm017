# 学习笔记

## 内容要点

### 动态规划

这里是结合了课程以及自己做题时的想法得出的一些体会和看法：

“重复子问题”的寻找依然是贯穿动态规划的思维里。这里是通过构建dp方程来对重复子问题进行数学定义。其基本条件是，__结果可以通过之前的计算结果集递推（包括正推或反推）得出__。

最经典的dp递推方程其实就是斐波拉契数列方程：`f(n) = f(n-1) + f(n-2)`。在这周的题目里，我都会先尝试将问题切割并且关联到fib方程里，或者是与其类似的变形体。很多问题都迎刃而解。

此外，根据dp方程的递推性特质。一般来说，dp的存储空间都可以通过特殊处理进行降维优化。比如对于fib这种一维O(n)空间复杂度的dp问题来讲，可以将其优化到O(1)的空间复杂度；对于[[221] 最大正方形](https://leetcode-cn.com/problems/maximal-square/description/)O(n*m)的空间复杂度的，可以将其优化到O(n);

### 解题要点

* 找出最小重复子问题
* 定义DP方程，并构造对应状态空间
* 程序推理（自顶向下或自底向上）即可

最后，dp就是一个基于数学递推方程(组)的解题方式，因此，只要你的递推公式是严谨的，剩下的，就交给数学，不需要做所谓的“人肉递归”。

## 练习

[[221] 最大正方形](maximal-square.js)

[[120] 三角形最小路径和](triangle.js)

[[62] 不同路径](unique-paths.js)

[[63] 不同路径 II](unique-paths-ii.js)

[[1143] 最长公共子序列](longest-common-subsequence.js)

## 习题部分

[[64] 最小路径和](minimum-path-sum.js)

[[91] 解码方法](decode-ways.js)
